using System;

namespace ParkingSys
{
    public class ParkingStructure
    {
        // Random number generator instance for various random operations throughout the class
        static Random rnd = new Random();

        // Event that gets triggered whenever there's a price cut in the parking structure
        public static event priceCutEvent priceCut;

        // Counter to keep track of the number of price cuts that have occurred
        private static int t = 1;

        // Constant representing the total number of price cuts allowed in the simulation
        private const int TotalPriceCuts = 20;

        // Current price of the parking
        private static double currentPrice = 15;

        // Method to change the current price of parking
        public static void changePrice(double newPrice)
        {
            // Check if any subscribers are listening to the priceCut event
            if (priceCut != null)
            {
                // If the new price is lower than the current price, it's a sale!
                if (newPrice < currentPrice)
                {
                    Console.WriteLine($"Parking blocks are on SALE at {newPrice}. SALE# {t}.");
                    priceCut(newPrice);  // Trigger the price cut event
                    Thread.Sleep(500);   // Small delay for simulation purposes
                    t++;                 // Increment the sale counter
                }

                // Update the current price if it's different from the new price
                if (newPrice != currentPrice)
                    currentPrice = newPrice;
            }
        }

        // Model to decide the pricing based on some internal logic (currently random between 10.0 and 40.0)
        private double pricingModel()
        {
            double price = 10.0 + (rnd.NextDouble() * (40.0 - 10.0));
            Console.WriteLine($"New Price generated by pricing model: {price}");
            return price;
        }

        // Thread method that handles the logic of price cuts
        public void handlePriceCut()
        {
            // Keep adjusting prices until the maximum number of price cuts has been reached
            while (t <= TotalPriceCuts)
            {
                while (Program.multiCellBuffer.CountFilledCells() > 0)
                {
                    completeRemainingOrder();
                    Thread.Sleep(500); // Small delay to avoid tight loop
                }

                // Random sleep to simulate variability in price cut timings
                Thread.Sleep(rnd.Next(1000, 2000));

                // Get a new price from the pricing model
                double price = pricingModel();

                // Attempt to change the price to the new price
                changePrice(price);
            }

            // Once all price cuts are done, mark the parking structure thread as not running
            Program.parkingStructureThreadRunning = false;

            // Notify the end of the simulation
            Console.WriteLine("Simulation Complete...");
        }

        // Method to process an order when it's placed
        public void placeOrder()
        {
            int randomness = (int)rnd.NextInt64(1, 3);
            
            if (Program.multiCellBuffer.CountFilledCells() > randomness)
            {
                
                Thread.Sleep(rnd.Next(500, 1000));
                // Fetch the order object from the MultiCellBuffer
                OrderClass orderObject = Program.multiCellBuffer.getOneCell();

                // Start a new thread to process the order
                Thread thread = new Thread(() => OrderProcessing.processOrder(orderObject, orderObject.UnitPrice));
                thread.Start();
            }
        }

        // Method to process an order when it's placed
        public void completeRemainingOrder()
        {
            // Fetch the order object from the MultiCellBuffer
            OrderClass orderObject = Program.multiCellBuffer.getOneCell();

            // Start a new thread to process the order
            Thread thread = new Thread(() => OrderProcessing.processOrder(orderObject, orderObject.UnitPrice));
            thread.Start();
        }
    }
}
